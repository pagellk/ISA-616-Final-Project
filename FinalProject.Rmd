---
title: "ISA 616 Final Project"
author: "Andrew Edwards, Nick Oakley, and Lauren Pagel"
date: "`r Sys.Date()`"
output:
  html_document:
      toc: yes
      toc_depth: 4
      toc_float:
        collapse: no
        smooth_scroll: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
if(require(pacman)==FALSE) install.packages("pacman")
pacman::p_load(DataExplorer, # For explorer and cleaning data by visualizing missing values.
               httr, # For downloading the data from the UCI
               tidyverse, # For data manipulation
               corrplot, # for heatmaps
               DataExplorer, #for exploring data
               skimr, # for nice summary of data
               readxl, #to read Excel files
               networkD3 # to create a Sankey Plot
               ) # For creating dummy variables of categorical variables automatically.)
library(dplyr)
if(require(knitr) == FALSE) install.packages("knitr")
if(require(kableExtra) == FALSE) install.packages("kableExtra")
```

# **Problem Statement**
The ISA department has multiple classes of students each year. However, each year the number of students who graduate as seniors with their undergraduate does not align with the number of students in the major the previous year. Our primary goal with this project is to restructure and classify the students in a way that the department can accurately anticipate for the correct number of graduates the year before. Secondly, along with graduation, we have been asked to research the data and understand where these students are going, what are the leading causes of students leaving, and to redesign the classification metrics for grade level.


# **Research Questions**
* What is the best way to classify student grade levels? Number of credit hours? Full semesters at Miami?
* Why are there fewer graduating seniors than estimated each year, and what is the cause for this drop-off?
  * Where are these students going?
* Are there indicators that can show when we estimate a student is about to graduate? We can look at number of credit hours, semesters at Miami, course performance and more.


# **Business Value Proposition**
```{r, echo=FALSE}
knitr::include_graphics('616 Final Project BVP.png')
```

## Customer Jobs

Our client for this project is the Information Systems and Analytics department at Miami, but more specifically, Dr. Benamati and Dr. Farmer. These two have a very important role in the ISA department to monitor the health of the organization and to appropriate allocate resources based on needs.

### Monitor the Overall Health of the Information Systems and Analytics Department as it Pertains to Departmental Entrollment

As the chairs of the department, Dr. Benamati and Dr. Farmer are tasked with monitoring the overall health and performance of the Information Systems and Analytics department. This can include monitoring departmental enrollment as it pertains to showing the amount of students who enter into ISA majors as freshmen, retention within the department, and ultimately, how many students graduate with a degree from the department. This health ultimately helps Dr. Benamati and Dr. Farmer argue for the case of the ISA department during the State of the Department and can help the department grow over time.

### Allocate Resources Appropriately Depending on the Size and Performance of the Department

Based on the health that is monitored from the department, Dr. Benamati and Dr. Farmer are tasked with allocating resources appropriately. This can include increasing the number of professors or course sections offered depending on the amount of ISA majors that are enrolled. 

## Customer Pains

### Lack of Clarity of BA/ISA Student Grade Classification and Expected Graduating Students
Student classification of grades has led to inaccurate data regarding the number of expected graduates. 

### Difficulty Understanding Departmental Enrollment
Due to misclassifications and other factors, there are inaccuracies that misrepresent the true enrollment of the ISA department

### Unclear Presentation of Data
The current table that is used to present enrollment data can be confusing and inaccurate.

## Customer Gains

### Be Able to Understand How Students are Classified as Freshmen, Sophomores, etc. in the Data Set
With the current data set, the current classification of grades has led to inaccurate data reporting when it comes to anticipating the number of graduates within the data set.

### Better Understand what Factors May Influence Departmental Enrollment in the ISA Department as Well as Where they Go if they Change their Major
Within the current data set, there is no way to estimate when a student is about to exit the ISA department, whether that be because they are about to graduate or because they are changing their major. Thus, it makes it difficult for the ISA department to allocate their resources to maximize student benefit.

## Products and Services

### Providing a New Classification Metric for Grade Level of Students (Freshman, Sophomore, etc.)
Take more factors into account to better determine expected graduation of students. Current method of classification by number of credit hours does not best reflect student year and expected graduation.

### Providing Insight for Departmental Enrollment Numbers and Graduation Rates
Better indicate when a student is about to graduate from the ISA department so that resources can be allocated effectively.

### Providing a More Informative Presentation of Department Enrollment Numbers
The current matrix visual within the State of the Department Presentation can be hard for a non-analytical audience to read to understand the enrollment numbers problem easily.

## Pain Relievers

### Accurate Grade Classification that Reflects Expected Graduation
With the current state of the data, the actual number of graduating seniors is less than the anticipated amount in the previous year. Through our work, we seek to relieve this pain to account for anticipated early graduations, transfers, etc. We also seek to find a better way to classify student grades rather than solely by number of credit hours taken.

### Greater Insights Into True Enrollment Numbers for the ISA Department
Through our solution, we will provide the ISA department with a more accurate reporting for the ISA department so that they are able to allocate resources and budget effectively for the upcoming year.

### Clear Presentation of the State of the Department
Through our solution, we will prepare a more effective presentation of the ISA department's numbers in the State of the Department presentation. This information will be well organized in a way that those who do not have a strong background in analytics are still able to obtain valuable insights.

## Gain Creators

### More Dedicated Resources Towards Retaining Students in the ISA Department
Our solution will give the ISA department the information they need to better plan for the upcoming year by providing estimates of the number of students that will come through the department and eventually graduate each year. This will allow both Dr. Benamati and Dr. Farmer to spend less time on this administrative task and instead on preparing for the longevity of the department.

### Better Classification System to Understand the Ages of Students and When They Are Likely to Graduate
Our solution will provide the ISA department with a better system to classify students by their grade level so they can better understand and predict the number of students who will graduate from the department.


# **Timeline for Completion**

1. Draft of Problem Statement - 
Due with checkpoint 1 materials on November 4th. Responsible stakeholder: Nick Oakley.

2. Develop Research Questions - 
Due with checkpoint 1 materials on November 4th. Responsible stakeholder: Andrew Edwards.

3. Business Value Propositions - 
Due with checkpoint 1 materials on November 4th. Responsible stakeholder: Lauren Pagel.

4. Upload Data into Document - 
Do by the EOD on November 5th after class. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

5. Clean Dataset - 
Work on in class on November 5th and 7th, finish by November 10th. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

6. Merge Datasets Together - 
Turned in with Project #2 Checkpoint on 11/17. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

7. Develop Metric to Count the Number of Students for Each Grade Level - 
Work on during class on 11/19 and 11/21. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

8. Begin Building Visualizations - 
Build out by the end of the week on 11/22. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

9. Draft of Final Presentation Slides - 
Have draft done by 11/26 before Thanksgiving Break. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

10. Draft Technical Report - 
Have draft done by 11/26 before Thanksgiving Break. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

11. Revise Technical Report - 
Finish revisions by 12/3. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

12. Revise Final Presentation Slides - 
Finish revisions by 12/3. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

13. Submit Final Slides and Technical Report - 
Submit by EOD December 5th. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.

14. Deliver Final Presentation - 
Present week of December 3rd. Responsible stakeholder: Andrew Edwards, Nick Oakley, Lauren Pagel.


# **Deliverables**

## Full Technical Report

This report will be submitted by 11:59pm on December 5th. This report will detail information about our data, cleaning process, results, and limitations of the data. The goal of this report is to explain our processes in a way that provides explicit clarity and resembles the characteristics of a reproducible data analysis.

## Presentation Slides

Another aspect of our project that we will deliver are our presentation slides, as well as our presentation. These will also be due by 11:59pm on December 5th, although our presentation may fall earlier. The goal of this presentation is to clearly articulate our findings to our audience and visualize the data in a way that is easy for someone with a non-technical background to understand.

## Reproducible Data Analysis

Along with our technical report and presentation, we will also submit a fully reproducible data analysis. This is so that as more students come through the department, this analysis will be able to rerun for new sets of students.


# **Analysis**

## **BA Majors**

### Counts of BA Students Across Cohort and Term Code

To begin our analysis, I am interested in looking at the raw counts of students enrolled in the BA major across different cohort terms and term codes in which they are enrolled at Miami. This code will filter my table for students who have BA Major indicated for at least one of their majors across different semesters for students in a particular cohort term. Below is our code output. Moving forward with analysis, I would be interested in showing how the number of students who graduated each semester could be implemented with this as we work to reclassify students. In addition, numbers from this table could be used to track student movement through various majors, should they change their major away from Business Analytics.

```{r, echo=FALSE}
BA = read.csv('data-clean/BA_Final.csv')
result <- BA |>
  dplyr::filter(`Major.1` == "BA Major" | `Major.2` == "BA Major" | `Major.3` == "BA Major") |>
  dplyr::group_by(`Cohort.Term`, `Term.Code`) |>
  dplyr::summarize(Num_Students = n_distinct(`Student.ID`), .groups = 'drop')


# Display the reshaped table
print(result)

```


### Graduation Counts for BA Majors by Academic Year

To provide ourselves with a good baseline before doing any further analysis, we want to generate an overarching graph that shows the number of students who have graduated for each academic year:

```{r, echo=FALSE}
# Determine the maximum Term.Code for each Student.ID to identify the graduation term
graduation_terms <- BA |>
  dplyr::group_by(`Student.ID`) |>
  dplyr::summarize(Max_Term_Code = max(`Term.Code`), .groups = 'drop')

# Filter the original data to only include rows where the Term.Code is the graduation term
graduated_students <- BA |>
  dplyr::inner_join(graduation_terms, by = c("Student.ID" = "Student.ID", "Term.Code" = "Max_Term_Code")) |>
  dplyr::filter(
    `Term.Code.Graduated` == `Term.Code`,
    `Major.1` == "BA Major" | `Major.2` == "BA Major" | `Major.3` == "BA Major"
  )

# Count the number of students who graduated each semester for each Term.Code
result <- graduated_students |>
  dplyr::group_by(`Term.Code`) |>
  dplyr::summarize(Num_Graduated = dplyr::n_distinct(`Student.ID`), .groups = 'drop')

# Create a mapping of Term.Code to academic year and term type
result <- result |> 
  dplyr::mutate(
    Academic_Year = dplyr::case_when(
      Term.Code %in% c(202510, 202520) ~ "2024-2025",
      Term.Code %in% c(202410, 202420) ~ "2023-2024",
      Term.Code %in% c(202310, 202320) ~ "2022-2023",
      Term.Code %in% c(202210, 202220) ~ "2021-2022",
      Term.Code %in% c(202110, 202120) ~ "2020-2021",
      Term.Code %in% c(202010, 202020) ~ "2019-2020",
      Term.Code %in% c(201910, 201920) ~ "2018-2019",
      Term.Code %in% c(201810, 201820) ~ "2017-2018",
      TRUE ~ as.character(Term.Code)  # Default case if needed
    ),
    Term_Type = dplyr::case_when(
      stringr::str_ends(as.character(Term.Code), "10") ~ "Fall",
      stringr::str_ends(as.character(Term.Code), "20") ~ "Spring",
      TRUE ~ "Unknown"
    )
  ) |>
  dplyr::mutate(Term_Type = factor(Term_Type, levels = c("Spring", "Fall")))

# Filter the result to only include academic years 2020-2021 and beyond
filtered_result <- result |>
  dplyr::filter(Academic_Year %in% c("2020-2021", "2021-2022", "2022-2023", "2023-2024", "2024-2025"))

# Create a stacked bar plot for the filtered data
ggplot2::ggplot(filtered_result, ggplot2::aes(x = Academic_Year, y = Num_Graduated, fill = Term_Type)) + 
  ggplot2::geom_bar(stat = "identity") + 
  ggplot2::geom_text(ggplot2::aes(label = Num_Graduated), position = ggplot2::position_stack(vjust = 0.5), size = 3.5) + 
  ggplot2::labs(
    title = "Number of BA Major Graduates by Term Code (2020-2021 and Beyond)",
    x = "Academic Year",
    y = "Number of Graduates",
    fill = "Term Type"
  ) + 
  ggplot2::theme_minimal() + 
  ggplot2::scale_fill_manual(values = c("Fall" = "#FFCCCB", "Spring" = "#C8102E")) + 
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5)
  )
```

This chart provides me with the number of graduation numbers the Business Analytics major has seen as a whole in the past 8 academic years. In general, here, I can see that most students with Business Analytics majors graduate in the spring semester as opposed to the fall. In addition, I am able to see how the department has improved as a whole in the past 8 academic years to increase the number of students who graduated with a degree in Business Analytics


### Graduation Counts for BA Majors - by Cohort and Term Code
This preliminary analysis shows the number of students from each cohort term who graduated each semester. From first looks, I notice that most students graduate during the spring of their senior year. This table, with the knowledge of the data we have, also indicates that there tends to be relatively few exceptions to this rule - as a significantly smaller number of students ten to graduate during the fall term, and few also graduate a full year early or late than their peers in their cohort term.
```{r, echo =FALSE}
# Determine the maximum Term.Code for each Student.ID to identify the graduation term
graduation_terms <- BA |>
  dplyr::group_by(`Student.ID`) |>
  dplyr::summarize(Max_Term_Code = max(`Term.Code`), .groups = 'drop')

# Filter the original data to only include rows where the Term.Code is the graduation term
graduated_students <- BA |>
  dplyr::inner_join(graduation_terms, by = c("Student.ID" = "Student.ID", "Term.Code" = "Max_Term_Code")) |>
  dplyr::filter(
    `Term.Code.Graduated` == `Term.Code`,
    `Major.1` == "BA Major" | `Major.2` == "BA Major" | `Major.3` == "BA Major"
  )

# Count the number of students who graduated each semester for each Term.Code
result <- graduated_students |>
  dplyr::group_by(`Cohort.Term`, `Term.Code`) |>
  dplyr::summarize(Num_Graduated = dplyr::n_distinct(`Student.ID`), .groups = 'drop')

result
```
As our first classification method, we want to explore classifying students by the number of semesters they have been enrolled at Miami University. To start, I want to show the incoming pipeline numbers for students in the Business Analytics Major in Fall 2023. These students will be classified by the number of semesters they have completed, which is defined as:

* A student who has completed 0 or 1 semesters will be a freshman
* A student who has completed 2 or 3 semesters will be a sophomore
* A student who has completed 4 or 5 semesters will be a junior
* A student who has completed 6 or 7 semesters will be a senior
* A student who has previously completed 8+ semesters will be classified as a super-senior

```{r, echo=FALSE}
# Step 1: Calculate the number of semesters completed before the term 202410
BA_prior <- BA |>
  dplyr::filter(Term.Code < 202410) |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarise(Semesters_Completed = dplyr::n_distinct(Term.Code), .groups = 'drop')
# Step 2: Join with the original data to get the classification based on semesters completed before 202410
result <- BA |>
  dplyr::filter(
    (Major.1 == "BA Major" | 
     Major.2 == "BA Major" | 
     Major.3 == "BA Major") & 
    Term.Code == 202410
  ) |>
  dplyr::left_join(BA_prior, by = "Student.ID") |>
  dplyr::mutate(Semesters_Completed = dplyr::if_else(is.na(Semesters_Completed), 0, Semesters_Completed)) |>
  dplyr::mutate(Classification = dplyr::case_when(
    Semesters_Completed < 2 ~ "Freshmen",
    Semesters_Completed == 2 | Semesters_Completed == 3 ~ "Sophomore",
    Semesters_Completed == 4 | Semesters_Completed == 5 ~ "Junior",
    Semesters_Completed == 6 | Semesters_Completed == 7 ~ "Senior",
    Semesters_Completed >= 8 ~ "Super Senior"
  )) |>
  dplyr::mutate(Classification = factor(Classification, levels = c("Freshmen", "Sophomore", "Junior", "Senior", "Super Senior"))) |>
  dplyr::group_by(Term.Code, Classification) |>
  dplyr::summarise(Num_Students = dplyr::n_distinct(Student.ID), .groups = 'drop') |>
  dplyr::arrange(Classification)
# Display the result in a formatted table
if(require(knitr)==FALSE) install.packages("knitr")
if(require(kableExtra)==FALSE) install.packages("kableExtra")
knitr::kable(result, col.names = c("Term Code", "Classification", "Number of Students"), caption = "Student Classification for Fall 2023") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light gray header
```

As we can see, this number of incoming seniors closely aligns with the number of students we saw graduate with a BA degree at the end of the 2023-2024 school year.

Let's more closely take a look at those who graduated last year:

```{r, echo=FALSE}
# Step 1: Determine the maximum Term.Code for each Student.ID to identify the graduation term
graduation_terms <- BA |>
  dplyr::group_by(`Student.ID`) |>
  dplyr::summarize(Max_Term_Code = max(`Term.Code`), .groups = 'drop')
# Filter the original data to only include rows where the Term.Code is the graduation term

  # Step 2: Filter the original data to only include rows where the Term.Code is the graduation term
graduated_students <- BA |>
  dplyr::inner_join(graduation_terms, by = c("Student.ID" = "Student.ID", "Term.Code" = "Max_Term_Code")) |>
  dplyr::filter(
     Term.Code.Graduated %in% c(202410, 202420),
    Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major"
  )

# Step 3: Count the number of terms each student was enrolled in
student_terms_count <- BA |>
  dplyr::filter(Student.ID %in% graduated_students$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarize(Num_Semesters = dplyr::n_distinct(Term.Code), .groups = 'drop')

# Step 4: Join the number of semesters back to the graduated students data
graduated_students <- graduated_students |>
  dplyr::left_join(student_terms_count, by = "Student.ID")

# Step 5: Count the number of graduates by the number of semesters
result <- graduated_students |>
  dplyr::group_by(Num_Semesters) |>
  dplyr::summarize(Num_Graduated = dplyr::n_distinct(Student.ID), .groups = 'drop')

if(require(knitr)==FALSE) install.packages("knitr")
if(require(kableExtra)==FALSE) install.packages("kableExtra")
knitr::kable(result, col.names = c("Number of Semesters", "Number of Graduates"), caption = "Graduates by Number of Semesters for Academic Year 2023-2024") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light gray header
```
Out of the 58 business analytics graduates we had for the academic year 2023-2024, we can see that many of them graduated over a wide variety of semesters. Many students were able to complete the degree in 7 semesters, perhaps explaining the winter graduate number. However, we are still able to see that the overwhelming majority of students in 2023-2024 graduated with a degree in Business Analytics following their 8th semester. 


To validate this assumption, let's show the distribution of number of semesters it takes for students to graduate:

```{r, echo=FALSE}
# Identify students who have graduated
graduated_students <- BA |>
  dplyr::group_by(`Student.ID`) |>
  dplyr::filter(max(`Term.Code`) == `Term.Code.Graduated`) |>
  dplyr::ungroup()

# Count the number of unique Term.Code entries for each Student.ID
semester_counts <- graduated_students |>
  dplyr::group_by(`Student.ID`) |>
  dplyr::summarize(Semester_Count = dplyr::n_distinct(`Term.Code`), .groups = 'drop')

# Summarize the distribution of semester counts
distribution <- semester_counts |>
  dplyr::group_by(Semester_Count) |>
  dplyr::summarize(Num_Students = dplyr::n(), .groups = 'drop')

# Calculate the total number of students
total_students <- sum(distribution$Num_Students)

# Add a percentage column
distribution <- distribution |>
  dplyr::mutate(Percentage = (Num_Students / total_students) * 100)

# Display the distribution in a formatted table with a colored header
knitr::kable(distribution, col.names = c("Number of Semesters", "Number of Students", "% of Total"), caption = "Distribution of Semesters to Graduation") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light gray header
```

With the current distribution of values within our data set, I can see that 80.13% of graduated students with a major in Business Analytics took 8 semesters to complete their degree. The next closest percentage is 7 semesters, which comes in around 10.10%. While there are certainly cases of students taking more or less time to graduate with their degree, the distribution of this data set leads me to believe that we should proceed by classifying student grade levels based upon the number of semesters of enrollment.


### Count of Student Grade Classification by Credit Hours
Before we examine the possibility of classifying students as per the number of semesters they have completed at Miami, let's first take a look into our data to see what the distribution of the number of credit hours students complete when they graduate.


```{r, echo=FALSE}
# Step 1: Identify the maximum Term.Code for each student
BA <- BA |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(max_term_code = max(Term.Code)) |>
  dplyr::ungroup()

# Step 2: Identify graduated students by comparing Term.Code.Graduated to their max Term.Code
BA <- BA |>
  dplyr::mutate(graduated = ifelse(Term.Code == Term.Code.Graduated & Term.Code == max_term_code, TRUE, FALSE))

# Step 3: Filter for students who have graduated and capture their cumulative credit hours at graduation
graduated_students <- BA |>
  dplyr::filter(graduated == TRUE, Term.Code < 202510, Cum.Credit.Hrs >=120) |>
  dplyr::select(Student.ID, Cum.Credit.Hrs)

# Step 4: Visualize the distribution of cumulative credit hours at graduation
if(require(ggplot2)==FALSE) install.packages("ggplot2")
ggplot2::ggplot(graduated_students, ggplot2::aes(x = Cum.Credit.Hrs)) +
  ggplot2::geom_histogram(binwidth = 5, color = "black", fill = "#C8102E", alpha = 0.7) +
  ggplot2::labs(
    title = "Distribution of Cumulative Credit Hours at Graduation",
    x = "Cumulative Credit Hours",
    y = "Number of Students"
  ) +
    ggplot2::theme_minimal()
```

As shown by this graph, students will graduate from Miami University with a wide variety of cumulative credit hours completed. This data could somewhat be impacted by how many transfer credits that a student has from high school, their number of majors and minors, and potentially if they want to be CPA eligible. Below we will detail some further statistics regarding those in our data set who have graduated with a Business Analytics Degree.

```{r, echo=FALSE}
# Step 1: Filter for graduated students with valid credit hours and a Term.Code.Graduated of 202510 or higher
graduated_students <- BA |>
  dplyr::filter(graduated == TRUE, !is.na(Cum.Credit.Hrs), Term.Code.Graduated < 202510, Cum.Credit.Hrs >=120)

graduation_stats <- graduated_students |>
  dplyr::summarise(
    min_credit_hours = min(Cum.Credit.Hrs, na.rm = TRUE),
    mean_credit_hours = mean(Cum.Credit.Hrs, na.rm = TRUE),
    max_credit_hours = max(Cum.Credit.Hrs, na.rm = TRUE)
  )
# Rename the columns before using kable
colnames(graduation_stats) <- c("Minimum Credit Hours", "Mean Credit Hours", "Maximum Credit Hours")
# Create the table with customized headers and styling
if(require(knitr)==FALSE) install.packages("knitr")
if(require(kableExtra)==FALSE) install.packages("kableExtra")
knitr::kable(graduation_stats, caption = "Graduated Students' Cumulative Credit Hours Statistics") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "responsive"),
      full_width = FALSE
  ) |>
  kableExtra::column_spec(1:3, bold = TRUE) |>  # Make header titles bold
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Change background color of the header row (light blue)
```
```{r, echo=FALSE}
# Assuming your data frame is named 'student_data'
result <- BA |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code)) |>
  dplyr::ungroup() |>
  dplyr::summarise(
    min_credit_hrs = min(Cum.Credit.Hrs),
    median_credit_hrs = median(Cum.Credit.Hrs),
    max_credit_hrs = max(Cum.Credit.Hrs)
  )
# Create the table with customized headers and styling
knitr::kable(result, caption = "Cumulative Credit Hours Statistics for First Term") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "responsive"),
    full_width = FALSE
  ) |>
  kableExtra::column_spec(1:3, bold = TRUE) |>  # Make header titles bold
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Change background color of the header row (light blue)
```
```{r, echo=FALSE}
# Step 1: Filter for graduated students and ensure non-missing credit hours
graduated_students <- BA |>
  dplyr::filter(graduated == TRUE & !is.na(Cum.Credit.Hrs))
# Step 2: Determine the number of majors for each student in their last term
graduated_students <- graduated_students |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::mutate(
    num_majors = dplyr::case_when(
      Major.1 != "None" & Major.2 == "None" & Major.3 == "None" ~ 1,
      Major.1 != "None" & Major.2 != "None" & Major.3 == "None" ~ 2,
      Major.1 != "None" & Major.2 != "None" & Major.3 != "None" ~ 3,
      TRUE ~ 0
    )
  ) |>
  dplyr::ungroup()
# Step 3: Calculate the mean number of Cum.Credit.Hrs for each group of majors
graduation_stats <- graduated_students |>
  dplyr::group_by(num_majors) |>
  dplyr::summarise(
    mean_credit_hours = mean(Cum.Credit.Hrs, na.rm = TRUE)
  )
# Rename the columns before using kable
colnames(graduation_stats) <- c("Number of Majors", "Mean Credit Hours")
# Create the table with customized headers and styling
knitr::kable(graduation_stats, caption = "Mean Credit Hours by Number of Majors for Graduated Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "responsive"),
    full_width = FALSE
  ) |>
  kableExtra::column_spec(1:2, bold = TRUE) |>  # Make header titles bold
  kableExtra::row_spec(0, background = "#C8102E", color="white")
```

From these three tables I am able to obtain a few insights that I can bring into future analyses: 

1. Students graduate from Miami's Business Analytics major with a wide variety of credit hours. 
2. Students often will transfer credit to Miami University from high school or from another higher institution...in a later analysis, it would be worth looking into the particular student who transferred in 130 hours.
3. As students increase their amount of majors, they are also increasing the number of credits they graduate with. This may be an important factor to consider when classifying student grades.

To proceed, we will explore the possibility of classifying students by the number of credit hours they have completed.

In our previous analyses, we were exploring the potential of classifying students in our database based upon the number of semesters they have been enrolled at Miami University. However, another potential area we may explore to classify students is based on the number of cumulative credit hours they have completed, whether at Miami University or elsewhere. Many students may have transfer credits through AP coursework from high school or from another college if they transferred. We suspect that BannerWeb is currently classifying students based on the number of cumulative credit hours they have completed currently, but have no inclination if that is true.

```{r, echo=FALSE}
BA |> 
    dplyr::filter(
    Major.1 == "BA Major" | 
    Major.2 == "BA Major" | 
    Major.3 == "BA Major"
  ) |> 
  dplyr::mutate(Classification = dplyr::case_when(
    Cum.Credit.Hrs >= 0 & Cum.Credit.Hrs < 30 ~ "Freshman",
    Cum.Credit.Hrs >= 30 & Cum.Credit.Hrs < 60 ~ "Sophomore",
    Cum.Credit.Hrs >= 60 & Cum.Credit.Hrs < 90 ~ "Junior",
    Cum.Credit.Hrs >= 90 ~ "Senior"
  )) |> 
  dplyr::group_by(Term.Code, Classification) |> 
  dplyr::summarise(Num_Students = dplyr::n_distinct(Student.ID)) |> 
  print()
```
I operationally defined a student's credit hour intake as follows:

* If a student is in their first semester they are automatically classified as a freshman.
* If a student has between 0-30 credit hours, they are classified as a freshman.
* If a student has between 30-60 credit hours, they are classified as a sophomore.
* If a student has between 60-90 credit hours, they are classified as a junior.
* If a student has 90+ credit hours, they are classified as a senior.

When I classify a student's grade classification, assuming that on average each student completes 15 credit hours per semester, I start to notice a couple of problems. For starters, let's examine the incoming pipeline number for last fall:  

```{r,echo=FALSE}
# Step 1: Calculate cumulative credit hours before the term 202410
BA_prior <- BA |>
  dplyr::filter(Term.Code < 202410) |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarise(Cum.Credit.Hrs.Before = max(Cum.Credit.Hrs, na.rm = TRUE), .groups = 'drop')
# Step 2: Join with the original data to get the classification based on credit hours before 202410
result <- BA |>
  dplyr::filter(
    (Major.1 == "BA Major" | 
     Major.2 == "BA Major" | 
     Major.3 == "BA Major") & 
      Term.Code == 202410
  ) |>
  dplyr::left_join(BA_prior, by = "Student.ID") |>
  dplyr::mutate(Cum.Credit.Hrs.Before = dplyr::if_else(is.na(Cum.Credit.Hrs.Before), 0, Cum.Credit.Hrs.Before)) |>
  dplyr::mutate(Classification = dplyr::case_when(
    Cum.Credit.Hrs.Before >= 0 & Cum.Credit.Hrs.Before < 30 ~ "Freshmen",
    Cum.Credit.Hrs.Before >= 30 & Cum.Credit.Hrs.Before < 60 ~ "Sophomore",
    Cum.Credit.Hrs.Before >= 60 & Cum.Credit.Hrs.Before < 90 ~ "Junior",
    Cum.Credit.Hrs.Before >= 90 ~ "Senior"
  )) |>
  dplyr::mutate(Classification = factor(Classification, levels = c("Freshmen", "Sophomore", "Junior", "Senior"))) |>
  dplyr::group_by(Term.Code, Classification) |>
  dplyr::summarise(Num_Students = dplyr::n_distinct(Student.ID), .groups = 'drop') |>
  dplyr::arrange(Classification)
# Display the result in a formatted table
if(require(knitr)==FALSE) install.packages("knitr")
if(require(kableExtra)==FALSE) install.packages("kableExtra")
knitr::kable(result, col.names = c("Term Code", "Classification", "Number of Students"), caption = "Pipeline Numbers for 2023-2024") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light gray header
```

As I look at this data, I see that my incoming pipeline numbers for seniors do not come close to matching the number of seniors who graduated in the academic year 2023-2024. From this, we are able to make two key conclusions: 

1. The number of cumulative credit hours a student has completed does not reflect their status to graduate.
2. While coming in with transfer credits is certainly beneficial for students, it is not always beneficial in helping them fill requirements for their particular degree program, which ultimately dictates their timeline to graduate.

### Cases of Students Graduating Early

From initially looking at the data, it appears that classifying students by the number of semesters they have completed is the most reliable. We want to start looking into the exceptions of the rule that students would graduate either earlier or later than their anticipated graduation date, or after 8 semesters they have completed at Miami University. 

Let's start by looking at the overall breakdown of these students who have graduated early with a Business Analytics major.

```{r, echo=FALSE}
# Identify students who have graduated and have "BA Major" in their graduation term
graduated_students <- BA |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == Term.Code.Graduated) |>
  dplyr::filter(Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major") |>
  dplyr::ungroup()

# Count the number of unique Term.Code entries for each Student.ID
semester_counts <- BA |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarize(Semester_Count = dplyr::n_distinct(Term.Code), .groups = 'drop')

# Join the semester counts with the graduated students
graduated_students <- graduated_students |>
  dplyr::inner_join(semester_counts, by = "Student.ID")

# Summarize the distribution of semester counts
distribution <- graduated_students |>
  dplyr::group_by(Semester_Count) |>
  dplyr::summarize(Num_Students = dplyr::n(), .groups = 'drop')

# Filter for students graduating in less than 8 semesters
distribution <- distribution |>
  dplyr::filter(Semester_Count < 8)

# Calculate the total number of students
total_students <- sum(distribution$Num_Students)

# Add a percentage column
distribution <- distribution |>
  dplyr::mutate(Percentage = (Num_Students / total_students) * 100)

# Display the distribution in a formatted table with a colored header
knitr::kable(distribution, col.names = c("Number of Semesters", "Number of Students", "% of Total"), caption = "Distribution of Semesters to Graduation for BA Majors") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header

```

Let's start by closely examining the factors that may have led to a student graduating in just four semesters.

```{r, echo=FALSE}
# Step 1: Calculate the maximum term code for each student
BA <- BA |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(max_term_code = max(Term.Code)) |>
  dplyr::ungroup()

# Step 2: Identify students who graduated in 4 semesters
students_4_semesters <- BA |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarize(
    Semester_Count = dplyr::n_distinct(Term.Code),
    max_term_code = max(Term.Code),
    Term.Code.Graduated = dplyr::first(Term.Code.Graduated)
  ) |>
  dplyr::filter(Semester_Count == 4, max_term_code == Term.Code.Graduated) |>
  dplyr::select(Student.ID)

# Step 3: Get the rows from the BA dataframe for these students
students_4_semesters_data <- BA |>
  dplyr::filter(Student.ID %in% students_4_semesters$Student.ID)

# Step 4: Drop multiple columns by name
students_4_semesters_data <- students_4_semesters_data |>
  dplyr::select(-X, -Major.2, -Major.3, -max_term_code, -graduated, -Term.Code.Graduated)


# Display the distribution in a formatted table with a colored header
if(require(knitr)==FALSE) install.packages("knitr")
if(require(kableExtra)==FALSE) install.packages("kableExtra")
knitr::kable(students_4_semesters_data, 
             caption = "Distribution of Semesters to Graduation") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")
 
```

As I look through the four semesters of this student's enrollment, the primary thing that jumps out at me is the number of cumulative credit hours that the student had completed their first semester. Having such a high number likely indicates that they either transferred a lot of credit from high school, or that they transferred to Miami from another school. This is a pattern we should continue to look at as we continue to develop our student classification mechanism further, as students with a high number of credit hours their first semester may be more likely to graduate early.

Let's look at student's who graduated in 6 semesters:

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 6 semesters
students_6_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 6) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the BA dataframe for these students
students_6_semesters_data <- BA |>
  dplyr::filter(Student.ID %in% students_6_semesters$Student.ID)

# Step 3: Filter for students who have "BA Major" in their final term
students_with_ba_major <- students_6_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_6_semesters <- students_6_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_ba_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hrs, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out students who graduated in term 202510
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::filter(Term.Code != 202510)

# Display the distribution in a formatted table with a colored header
knitr::kable(graduated_students_6_semesters, 
             col.names = c("Student ID", "Cohort Term", "Term Code", "Cumulative Credit Hours", "Cumulative GPA", "Major(s)"), 
             caption = "Distribution of Semesters to Graduation") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header

```

Above is the table showing the stats for students who graduated from Miami University in just 6 semesters with a degree in Business Analytics. Let's summarize some of this detail at a high level:

```{r, echo=FALSE}
# Calculate the mean number of credit hours during the first semester
mean_first_semester_credits <- graduated_students_6_semesters |>
  dplyr::filter(Term.Code == Cohort.Term) |>
  dplyr::summarize(mean_credits = mean(`Cum.Credit.Hrs`, na.rm = TRUE)) |>
  dplyr::pull(mean_credits)

# Calculate the mean GPA at graduation
mean_graduation_gpa <- graduated_students_6_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::summarize(mean_gpa = mean(`Cum.UG.Crs.GPA`, na.rm = TRUE)) |>
  dplyr::pull(mean_gpa) |> 
  mean(na.rm = TRUE)  # Get the overall mean across all students

# Calculate the percentage of students who graduated with more than one major
# We only want one result for the percentage, not grouped by Student.ID
percentage_more_than_one_major <- graduated_students_6_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::mutate(num_majors = stringr::str_count(All_Majors, ", ") + 1) |>
  dplyr::summarize(more_than_one_major = sum(num_majors > 1)) |>
  dplyr::ungroup() |>
  dplyr::summarize(percentage = (sum(more_than_one_major > 0) / n()) * 100) |>
  dplyr::pull(percentage)

# Create a summary table with a single row
summary_table <- tibble::tibble(
  `Mean First Semester Credits` = mean_first_semester_credits,
  `Mean Graduation GPA` = mean_graduation_gpa,
  `Percentage with More Than One Major` = percentage_more_than_one_major
)

knitr::kable(summary_table, 
             caption = "Summary of Student Graduation Data") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color = "white")  # Apply colored header



```

At a high level, the only item that sticks out is the average number of credit hours completed in the first semester. This number seems to be particularly higher amongst students who have graduated in both 4 and 6 semesters. Following the traditional college schedule of taking 15 credit hours per semester, we do not expect students to hit 60 credit hours until the end of their sophomore years. Thus, as we explore additional methods to classify students with grade levels, we should consider flagging these students who may have the potential to complete their degrees earlier than anticipated.

Another factor we want to examine is how many credit hours these students are taking per semester. Students who may be taking more credit hours may be on track to graduate earlier.

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 6 semesters
students_6_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 6) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the BA dataframe for these students
students_6_semesters_data <- BA |>
  dplyr::filter(Student.ID %in% students_6_semesters$Student.ID)

# Step 3: Filter for students who have "BA Major" in their final term
students_with_ba_major <- students_6_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_6_semesters <- students_6_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_ba_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hrs, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out students who graduated in term 202510
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::filter(Term.Code != 202510)

# Step 8: Calculate the credit hours per semester
credit_hours_per_semester <- students_6_semesters_data |>
  dplyr::filter(Student.ID %in% graduated_students_6_semesters$Student.ID) |>
  dplyr::arrange(Student.ID, Term.Code) |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(Credit_Hours_Semester = Cum.Credit.Hrs - dplyr::lag(Cum.Credit.Hrs, default = 0)) |>
  dplyr::ungroup()

# Step 9: Calculate the aggregated average credit hours per semester
total_credit_hours <- sum(credit_hours_per_semester$Credit_Hours_Semester, na.rm = TRUE)
total_semesters <- nrow(credit_hours_per_semester)
avg_credit_hours_per_semester_aggregated <- total_credit_hours / total_semesters

# Display the aggregated average credit hours per semester
knitr::kable(data.frame(Average_Credit_Hours_Per_Semester = avg_credit_hours_per_semester_aggregated), 
             col.names = c("Average Credit Hours per Semester"), 
             caption = "Aggregated Average Credit Hours per Semester for Graduated Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

From this, I can see that students who are graduating in 6 semesters are taking on average, 16.41 credit hours per semester. This is above the 15 credit hour standard that is asked of students, implying that part of the reason these students may be in a position to graduate early is because they are taking more credit hours than the average student. The average credit hour intake for all students is shown below:

```{r, echo=FALSE}
# Calculate the credit hours per semester for all students
credit_hours_per_semester_all <- BA |>
  dplyr::arrange(Student.ID, Term.Code) |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(Credit_Hours_Semester = Cum.Credit.Hrs - dplyr::lag(Cum.Credit.Hrs, default = 0)) |>
  dplyr::ungroup()

# Calculate the aggregated average credit hours per semester for all students
total_credit_hours_all <- sum(credit_hours_per_semester_all$Credit_Hours_Semester, na.rm = TRUE)
total_semesters_all <- nrow(credit_hours_per_semester_all)
avg_credit_hours_per_semester_all <- total_credit_hours_all / total_semesters_all

# Display the aggregated average credit hours per semester for all students
knitr::kable(data.frame(Average_Credit_Hours_Per_Semester = avg_credit_hours_per_semester_all), 
             col.names = c("Average Credit Hours per Semester"), 
             caption = "Aggregated Average Credit Hours per Semester for All Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

As we can see, all students in our database are taking on average 13.66 credit hours per semester. Thus, another sign that a student may be on track to graduate early can be defined as taking an average amount of credit hours that is significantly above the average.


### Cases of Students Graduating Late

Now that we have examined factors into students who have graduated sooner than 8 semesters, we also want to consider the possibility that a student would take longer than 8 semesters to graduate. Let's show the distribution of students who have taken longer than 8 semesters to graduate:

```{r, echo=FALSE}
# Identify students who have graduated and have "BA Major" in their graduation term
graduated_students <- BA |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == Term.Code.Graduated) |>
  dplyr::filter(Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major") |>
  dplyr::ungroup()

# Count the number of unique Term.Code entries for each Student.ID
semester_counts <- BA |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarize(Semester_Count = dplyr::n_distinct(Term.Code), .groups = 'drop')

# Join the semester counts with the graduated students
graduated_students <- graduated_students |>
  dplyr::inner_join(semester_counts, by = "Student.ID")

# Summarize the distribution of semester counts
distribution <- graduated_students |>
  dplyr::group_by(Semester_Count) |>
  dplyr::summarize(Num_Students = dplyr::n(), .groups = 'drop')

# Filter for students graduating in less than 8 semesters
distribution <- distribution |>
  dplyr::filter(Semester_Count > 8)

# Calculate the total number of students
total_students <- sum(distribution$Num_Students)

# Add a percentage column
distribution <- distribution |>
  dplyr::mutate(Percentage = (Num_Students / total_students) * 100)

# Display the distribution in a formatted table with a colored header
knitr::kable(distribution, col.names = c("Number of Semesters", "Number of Students", "% of Total"), caption = "Distribution of Semesters to Graduation for BA Majors") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

Out of students who are graduating late, it appears that it takes them no longer than 10 semesters to complete their degree. Let's start by drilling into students who took 9 semesters to obtain a degree in Business Analytics.

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 9 semesters
students_9_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 9) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the BA dataframe for these students
students_9_semesters_data <- BA |>
  dplyr::filter(Student.ID %in% students_9_semesters$Student.ID)

# Step 3: Filter for students who have "BA Major" in their final term
students_with_ba_major <- students_9_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_9_semesters <- students_9_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_ba_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hrs, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out student ID 8226483
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::filter(Student.ID != 8226483)

# Display the distribution in a formatted table with a colored header
knitr::kable(graduated_students_9_semesters, 
             col.names = c("Student ID", "Cohort Term", "Term Code", "Cumulative Credit Hours", "Cumulative GPA", "Major(s)"), 
             caption = "Distribution of Semesters to Graduation") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

This table shows the details for both a student's first and last semester assuming they graduated in 9 semesters. Here are some of the high level statistics:

```{r, echo=FALSE}
# Calculate the mean number of credit hours during the first semester
mean_first_semester_credits <- graduated_students_9_semesters |>
  dplyr::filter(Term.Code == Cohort.Term) |>
  dplyr::summarize(mean_credits = mean(`Cum.Credit.Hrs`, na.rm = TRUE)) |>
  dplyr::pull(mean_credits)

# Calculate the mean GPA at graduation
mean_graduation_gpa <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::summarize(mean_gpa = mean(`Cum.UG.Crs.GPA`, na.rm = TRUE)) |>
  dplyr::pull(mean_gpa) |> 
  mean(na.rm = TRUE)  # Get the overall mean across all students

# Calculate the percentage of students who graduated with more than one major
# We only want one result for the percentage, not grouped by Student.ID
percentage_more_than_one_major <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::mutate(num_majors = stringr::str_count(All_Majors, ", ") + 1) |>
  dplyr::summarize(more_than_one_major = sum(num_majors > 1)) |>
  dplyr::ungroup() |>
  dplyr::summarize(percentage = (sum(more_than_one_major > 0) / n()) * 100) |>
  dplyr::pull(percentage)

# Create a summary table with a single row
summary_table <- tibble::tibble(
  `Mean First Semester Credits` = mean_first_semester_credits,
  `Mean Graduation GPA` = mean_graduation_gpa,
  `Percentage with More Than One Major` = percentage_more_than_one_major
)

# Display the summary table
knitr::kable(summary_table, 
             caption = "Summary of Student Graduation Data") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  )|>
  kableExtra::row_spec(0, background = "#C8102E", color = "white")  # Apply colored header
```

This table confirms some of our initial assumptions about students who take longer than 8 semesters to graduate. Not shockingly, we see that these students often have significantly less credit hours after their first semester at Miami University. In addition we see that these students have a much lower GPA than students who graduate early. Let's check the average graduation GPA to see if this differs significantly.

```{r, echo=FALSE}
# Step 1: Identify students who graduated with a "BA Major"
students_with_ba_major <- BA |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major") |>
  dplyr::ungroup()

# Step 2: Calculate the average GPA for these students
average_gpa_ba_major <- students_with_ba_major |>
  dplyr::summarize(Average_GPA = mean(Cum.UG.Crs.GPA, na.rm = TRUE))

# Display the average GPA
knitr::kable(average_gpa_ba_major, 
             col.names = c("Average GPA"), 
             caption = "Average GPA for Students Graduated with BA Major") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white") 
```

This table above confirms our general assumption that students who are graduating in more than 8 semesters have a lower GPA than the student body in general. These students also maybe have taken gap semesters or have failed classes, which they have had to retake. Let's look at the average number of credit hours these students are taking per semester.

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 6 semesters
students_9_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 9) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the BA dataframe for these students
students_9_semesters_data <- BA |>
  dplyr::filter(Student.ID %in% students_9_semesters$Student.ID)

# Step 3: Filter for students who have "BA Major" in their final term
students_with_ba_major <- students_9_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_9_semesters <- students_9_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_ba_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hrs, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out students who graduated in term 202510
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::filter(Term.Code != 202510)

# Step 8: Calculate the credit hours per semester
credit_hours_per_semester <- students_9_semesters_data |>
  dplyr::filter(Student.ID %in% graduated_students_9_semesters$Student.ID) |>
  dplyr::arrange(Student.ID, Term.Code) |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(Credit_Hours_Semester = Cum.Credit.Hrs - dplyr::lag(Cum.Credit.Hrs, default = 0)) |>
  dplyr::ungroup()

# Step 9: Calculate the aggregated average credit hours per semester
total_credit_hours <- sum(credit_hours_per_semester$Credit_Hours_Semester, na.rm = TRUE)
total_semesters <- nrow(credit_hours_per_semester)
avg_credit_hours_per_semester_aggregated <- total_credit_hours / total_semesters

# Display the aggregated average credit hours per semester
knitr::kable(data.frame(Average_Credit_Hours_Per_Semester = avg_credit_hours_per_semester_aggregated), 
             col.names = c("Average Credit Hours per Semester"), 
             caption = "Aggregated Average Credit Hours per Semester for Graduated Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

This data confirms our assumption that students who have graduated in 9 semesters have taken less of a credit hour load than the normal student body. The average amount of credit hours that students are completing on a semesterly basis may be something for the ISA department to consider as they track student progress, and potentially try and flag students who are falling behind.

Now that we have closely examined students who have graduated in 9 semesters, let's see if this pattern is still true for students who have graduated in 10 semesters.

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 10 semesters
students_10_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 10) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the BA dataframe for these students
students_10_semesters_data <- BA |>
  dplyr::filter(Student.ID %in% students_10_semesters$Student.ID)

# Step 3: Filter for students who have "BA Major" in their final term
students_with_ba_major <- students_10_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_10_semesters <- students_10_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_ba_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hrs, Cum.UG.Crs.GPA, All_Majors)

# Display the distribution in a formatted table with a colored header
knitr::kable(graduated_students_10_semesters, 
             col.names = c("Student ID", "Cohort Term", "Term Code", "Cumulative Credit Hours", "Cumulative GPA", "Major(s)"), 
             caption = "Distribution of Semesters to Graduation") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

From the table above, one pattern that I notice is that most of these students who graduate in 10 semesters had a major change, and most of which happened to be between different academic divisions. Different academic divisions at Miami, such as FSB and CAS have significantly different requirements for their majors, which may add more work for students to complete to graduate on time. 

Let's look at some of these factors on a higher level: 

```{r, echo=FALSE}
# Calculate the mean number of credit hours during the first semester
mean_first_semester_credits <- graduated_students_10_semesters |>
  dplyr::filter(Term.Code == Cohort.Term) |>
  dplyr::summarize(mean_credits = mean(`Cum.Credit.Hrs`, na.rm = TRUE)) |>
  dplyr::pull(mean_credits)

# Calculate the mean GPA at graduation
mean_graduation_gpa <- graduated_students_10_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::summarize(mean_gpa = mean(`Cum.UG.Crs.GPA`, na.rm = TRUE)) |>
  dplyr::pull(mean_gpa) |> 
  mean(na.rm = TRUE)  # Get the overall mean across all students

# Calculate the percentage of students who graduated with more than one major
# We only want one result for the percentage, not grouped by Student.ID
percentage_more_than_one_major <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::mutate(num_majors = stringr::str_count(All_Majors, ", ") + 1) |>
  dplyr::summarize(more_than_one_major = sum(num_majors > 1)) |>
  dplyr::ungroup() |>
  dplyr::summarize(percentage = (sum(more_than_one_major > 0) / n()) * 100) |>
  dplyr::pull(percentage)

# Create a summary table with a single row
summary_table <- tibble::tibble(
  `Mean First Semester Credits` = mean_first_semester_credits,
  `Mean Graduation GPA` = mean_graduation_gpa,
  `Percentage with More Than One Major` = percentage_more_than_one_major
)

# Display the summary table
knitr::kable(summary_table, 
             caption = "Summary of Student Graduation Data") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color = "white")  # Apply colored header
```

Similarly to the students who graduated with a Business Analytics major in 9 semesters, those who graduated in 10 semesters have a lower cumulative GPA and less credit hours when they first start at Miami.

Let's see if the number of credit hours they are taking per semester has an impact on their graduation.

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 6 semesters
students_10_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 10) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the BA dataframe for these students
students_10_semesters_data <- BA |>
  dplyr::filter(Student.ID %in% students_10_semesters$Student.ID)

# Step 3: Filter for students who have "BA Major" in their final term
students_with_ba_major <- students_10_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "BA Major" | Major.2 == "BA Major" | Major.3 == "BA Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_10_semesters <- students_10_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_ba_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hrs, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out students who graduated in term 202510
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::filter(Term.Code != 202510)

# Step 8: Calculate the credit hours per semester
credit_hours_per_semester <- students_10_semesters_data |>
  dplyr::filter(Student.ID %in% graduated_students_10_semesters$Student.ID) |>
  dplyr::arrange(Student.ID, Term.Code) |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(Credit_Hours_Semester = Cum.Credit.Hrs - dplyr::lag(Cum.Credit.Hrs, default = 0)) |>
  dplyr::ungroup()

# Step 9: Calculate the aggregated average credit hours per semester
total_credit_hours <- sum(credit_hours_per_semester$Credit_Hours_Semester, na.rm = TRUE)
total_semesters <- nrow(credit_hours_per_semester)
avg_credit_hours_per_semester_aggregated <- total_credit_hours / total_semesters

# Display the aggregated average credit hours per semester
knitr::kable(data.frame(Average_Credit_Hours_Per_Semester = avg_credit_hours_per_semester_aggregated), 
             col.names = c("Average Credit Hours per Semester"), 
             caption = "Aggregated Average Credit Hours per Semester for Graduated Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

Similarly to students who graduated in 9 semesters, students who took 10 semesters to graduate have less average credit hours per semester than an average Business Analytics graduate.

From our analyses of students who have graduated behind schedule, we have three major takeaways for the ISA department to potentially consider as they flag students who may be falling behind in the program: 

1. Cumulative GPA - Students who may be at risk for graduating later than their peers may be doing so because they failed a core class that they would have to retake. The ISA department should consider flagging students with a cumulative GPA under a 3.0 during their time at Miami, as these students are at a significantly higher risk of graduating later than their peers in the program.
2. Number of Credit Hours Taken per Semester - This may coincide with GPA, as a student will not get credit for a class if they do not pass it. However, the department should be closely monitoring these numbers to identify students who may be at risk of completing their Business Analytics degree late. Miami University considers a full time student to be one that takes 12 credit hours per semester, so students taking an average less than that may be on a path to fall behind.
3. Changing Majors - The department also has data to track a student's progress through their time at Miami. Although this may not be as significant of a factor as GPA or Credit Hours, the department should consider closely watching students who change their major, particularly between academic divisions. These students will likely have an increased number of requirements asked of them because of the change, and when they change their major should also be considered as students who change their major later in their academic career will be less likely to finish on time. 

### Overall Findings for BA Majors
To summarize, we have found that classification by number of semesters completed appears to be the most accurate method. Thus, we will add a column to our dataset to keep track of student classification as they progress through their time at Miami.

```{r, echo=FALSE}
# Step 1: Ensure unique term codes for each student
BA_unique_terms <- BA |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE)
# Step 2: Calculate the number of semesters completed for each student up to each term
BA_with_semesters <- BA_unique_terms |>
  dplyr::group_by(Student.ID) |>
  dplyr::arrange(Term.Code) |>
  dplyr::mutate(Semesters_Completed = dplyr::row_number() - 1) |>
  dplyr::ungroup()
# Step 3: Add classification based on the number of semesters completed
BA_with_classification <- BA_with_semesters |>
  dplyr::mutate(Classification = dplyr::case_when(
    Semesters_Completed < 2 ~ "Freshman",
    Semesters_Completed == 2 | Semesters_Completed == 3 ~ "Sophomore",
    Semesters_Completed == 4 | Semesters_Completed == 5 ~ "Junior",
    Semesters_Completed == 6 | Semesters_Completed == 7 ~ "Senior",
    Semesters_Completed >= 8 ~ "Super Senior"
  )) |>
  dplyr::mutate(Classification = factor(Classification, levels = c("Freshman", "Sophomore", "Junior", "Senior", "Super Senior"))) |>
  dplyr::arrange(Student.ID, Term.Code)  # Sort by Student.ID and Term.Code
# Display a sample of the updated dataset
head(BA_with_classification)

```




## **IS Majors**

After performing all of these calculations and transformations on the BA dataset, we can now replicate the same actions for the IS dataset. That way, we can gather the same information and insights for these students, while also keeping the majors separate. This is important because these two majors have different numbers regarding enrollment, expected graduations, and credit hours. Also by keeping the datasets separate, it will be easier for the ISA department to target specific factors for each major, and determine new courses of action that may need to occur in order to encourage stronger academic development for that specific major.

All of the calculations below are ran to support our analyses and decisions made from the BA dataset. Many of the charts and metrics further support the same direction from BA students, while other calculations have a different direction, but still support the overall idea.


### Counts of IS Students Across Cohort and Term Code

We will begin our analysis by creating a general table of all IS students across each cohort and term code. For the sake of our analysis, all Cybersecurity Management majors will be grouped in with the Information Systems Majors.

```{r, echo=FALSE}
IS = read.csv('data-clean/IS_Final.csv')
result <- IS |>
  dplyr::filter(`Major.1` == "IS Major" | `Major.2` == "IS Major" | `Major.3` == "IS Major" |
                  `Major.1` == "Cybersecurity Mgt Major" |  `Major.2` == "Cybersecurity Mgt Major" | `Major.3` == "Cybersecurity Mgt Major") |>
  dplyr::group_by(`Cohort.Term`, `Term.Code`) |>
  dplyr::summarize(Num_Students = n_distinct(`Student.ID`), .groups = 'drop')
IS <- IS %>% filter(Student.ID != 9885956) ## Error observation

# Display the reshaped table
print(result)

```


### Graduation Counts for IS Majors by Academic Year

Similarly to what we did for Business Analytics majors, we will start by showing the number of IS and Cybersecurity graduates across each academic year, which will serve as the basis for the rest of our analysis.

```{r, echo=FALSE}
# Determine the maximum Term.Code for each Student.ID to identify the graduation term
graduation_terms <- IS |>
  dplyr::group_by(`Student.ID`) |>
  dplyr::summarize(Max_Term_Code = max(`Term.Code`), .groups = 'drop')

# Filter the original data to only include rows where the Term.Code is the graduation term
graduated_students <- IS |>
  dplyr::inner_join(graduation_terms, by = c("Student.ID" = "Student.ID", "Term.Code" = "Max_Term_Code")) |>
  dplyr::filter(
    `Term.Code.Graduated` == `Term.Code`,
    `Major.1` == "IS Major" | `Major.2` == "IS Major" | `Major.3` == "IS Major" |
     `Major.1` == "Cybersecurity Mgt Major" |  `Major.2` == "Cybersecurity Mgt Major" | 
      `Major.3` == "Cybersecurity Mgt Major"
  )

# Count the number of students who graduated each semester for each Term.Code
result <- graduated_students |>
  dplyr::group_by(`Term.Code`) |>
  dplyr::summarize(Num_Graduated = dplyr::n_distinct(`Student.ID`), .groups = 'drop')

# Create a mapping of Term.Code to academic year and term type
result <- result |> 
  dplyr::mutate(
    Academic_Year = dplyr::case_when(
      Term.Code %in% c(202510, 202520) ~ "2024-2025",
      Term.Code %in% c(202410, 202420) ~ "2023-2024",
      Term.Code %in% c(202310, 202320) ~ "2022-2023",
      Term.Code %in% c(202210, 202220) ~ "2021-2022",
      Term.Code %in% c(202110, 202120) ~ "2020-2021",
      Term.Code %in% c(202010, 202020) ~ "2019-2020",
      Term.Code %in% c(201910, 201920) ~ "2018-2019",
      Term.Code %in% c(201810, 201820) ~ "2017-2018",
      TRUE ~ as.character(Term.Code)  # Default case if needed
    ),
    Term_Type = dplyr::case_when(
      stringr::str_ends(as.character(Term.Code), "10") ~ "Fall",
      stringr::str_ends(as.character(Term.Code), "20") ~ "Spring",
      TRUE ~ "Unknown"
    )
  ) |>
  dplyr::mutate(Term_Type = factor(Term_Type, levels = c("Spring", "Fall")))

# Create a stacked bar plot
ggplot2::ggplot(result, ggplot2::aes(x = Academic_Year, y = Num_Graduated, fill = Term_Type)) + 
  ggplot2::geom_bar(stat = "identity") + 
  ggplot2::geom_text(ggplot2::aes(label = Num_Graduated), position = ggplot2::position_stack(vjust = 0.5), size = 3.5) + 
  ggplot2::labs(
    title = "Number of IS Major Graduates by Term Code",
    x = "Academic Year",
    y = "Number of Graduates",
    fill = "Term Type"
  ) + 
  ggplot2::theme_minimal() + 
  ggplot2::scale_fill_manual(values = c("Fall" = "#FFCCCB", "Spring" = "#C8102E")) + # Custom colors for Fall and Spring
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5)  # Center the title
  )
```

As we can see, the IS data set is significantly smaller than the BA dataset due to less students enrolled in the major. 

We will continue our analysis of the Information Systems Majors by attempting to classify these students by both credit hours and number of semesters completed.

### Graduation Counts for IS Majors - by Cohort and Term Code
We will first try to group graduates across each term code by their cohort term.

```{r, echo =FALSE}
# Filter the original data to only include rows where the Term.Code is the graduation term
graduated_students <- IS |>
  dplyr::inner_join(graduation_terms, by = c("Student.ID" = "Student.ID", "Term.Code" = "Max_Term_Code")) |>
  dplyr::filter(
    `Term.Code.Graduated` == `Term.Code`,
    (`Major.1` == "IS Major" | `Major.2` == "IS Major" | `Major.3` == "IS Major") |
    (`Major.1` == "Cybersecurity Mgt Major" | `Major.2` == "Cybersecurity Mgt Major" | `Major.3` == "Cybersecurity Mgt Major")
  )

# Count the number of students who graduated each semester for each Term.Code
result <- graduated_students |>
  dplyr::group_by(`Cohort.Term`, `Term.Code`) |>
  dplyr::summarize(Num_Graduated = dplyr::n_distinct(`Student.ID`), .groups = 'drop')

result
```
As our first classification method, we want to explore classifying students by the number of semesters they have been enrolled at Miami University. To start, I want to show the incoming pipeline numbers for students in the Business Analytics Major in Fall 2023. These students will be classified by the number of semesters they have completed, which is defined as:

* A student who has completed 0 or 1 semesters will be a freshman
* A student who has completed 2 or 3 semesters will be a sophomore
* A student who has completed 4 or 5 semesters will be a junior
* A student who has completed 6 or 7 semesters will be a senior
* A student who has previously completed 8+ semesters will be classified as a super-senior

```{r, echo=FALSE}
# Step 1: Calculate the number of semesters completed before the term 202410
IS_prior <- IS |>
  dplyr::filter(Term.Code < 202410) |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarise(Semesters_Completed = dplyr::n_distinct(Term.Code), .groups = 'drop')

# Step 2: Join with the original data to get the classification based on semesters completed before 202410
result <- IS |>
  dplyr::filter(
    (Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major") & 
    Term.Code == 202410
  ) |>
  dplyr::left_join(IS_prior, by = "Student.ID") |>
  dplyr::mutate(Semesters_Completed = dplyr::if_else(is.na(Semesters_Completed), 0, Semesters_Completed)) |>
  dplyr::mutate(Classification = dplyr::case_when(
    Semesters_Completed < 2 ~ "Freshmen",
    Semesters_Completed == 2 | Semesters_Completed == 3 ~ "Sophomore",
    Semesters_Completed == 4 | Semesters_Completed == 5 ~ "Junior",
    Semesters_Completed == 6 | Semesters_Completed == 7 ~ "Senior",
    Semesters_Completed >= 8 ~ "Super Senior"
  )) |>
  dplyr::mutate(Classification = factor(Classification, levels = c("Freshmen", "Sophomore", "Junior", "Senior", "Super Senior"))) |>
  dplyr::group_by(Term.Code, Classification) |>
  dplyr::summarise(Num_Students = dplyr::n_distinct(Student.ID), .groups = 'drop') |>
  dplyr::arrange(Classification)

# Display the result in a formatted table
if(require(knitr)==FALSE) install.packages("knitr")
if(require(kableExtra)==FALSE) install.packages("kableExtra")
knitr::kable(result, col.names = c("Term Code", "Classification", "Number of Students"), caption = "Student Classification for Fall 2023") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light gray header
```

As we can see, this number of incoming seniors closely aligns with the number of students we saw graduate with a BA degree at the end of the 2023-2024 school year.

Let's more closely take a look at those who graduated last year:

```{r, echo=FALSE}
# Step 1: Determine the maximum Term.Code for each Student.ID to identify the graduation term
graduation_terms <- IS |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarize(Max_Term_Code = max(Term.Code), .groups = 'drop')
# Step 2: Filter the original data to only include rows where the Term.Code is the graduation term
graduated_students <- IS |>
  dplyr::inner_join(graduation_terms, by = c("Student.ID" = "Student.ID", "Term.Code" = "Max_Term_Code")) |>
  dplyr::filter(
    Term.Code.Graduated %in% c(202410, 202420),
    (Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major")
  )

# Step 3: Count the number of terms each student was enrolled in
student_terms_count <- IS |>
  dplyr::filter(Student.ID %in% graduated_students$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarize(Num_Semesters = dplyr::n_distinct(Term.Code), .groups = 'drop')

# Step 4: Join the number of semesters back to the graduated students data
graduated_students <- graduated_students |>
  dplyr::left_join(student_terms_count, by = "Student.ID")
# Step 5: Count the number of graduates by the number of semesters
result <- graduated_students |>
  dplyr::group_by(Num_Semesters) |>
  dplyr::summarize(Num_Graduated = dplyr::n_distinct(Student.ID), .groups = 'drop')

if(require(knitr)==FALSE) install.packages("knitr")
if(require(kableExtra)==FALSE) install.packages("kableExtra")
knitr::kable(result, col.names = c("Number of Semesters", "Number of Graduates"), caption = "Graduates by Number of Semesters for Academic Year 2023-2024") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light gray header
```

As shown by this table, the vast majority of my IS graduates last year completed their degree in 8 semesters, with a few exceptions. Let's see if this rule holds true for other academic years in our database.

Let's show the distribution of number of semesters it takes for students to graduate:

```{r, echo=FALSE}
# Identify students who have graduated
graduated_students <- IS |>
  dplyr::group_by(`Student.ID`) |>
  dplyr::filter(max(`Term.Code`) == `Term.Code.Graduated`) |>
  dplyr::ungroup()

# Count the number of unique Term.Code entries for each Student.ID
semester_counts <- graduated_students |>
  dplyr::group_by(`Student.ID`) |>
  dplyr::summarize(Semester_Count = dplyr::n_distinct(`Term.Code`), .groups = 'drop')

# Summarize the distribution of semester counts
distribution <- semester_counts |>
  dplyr::group_by(Semester_Count) |>
  dplyr::summarize(Num_Students = dplyr::n(), .groups = 'drop')

# Calculate the total number of students
total_students <- sum(distribution$Num_Students)

# Add a percentage column
distribution <- distribution |>
  dplyr::mutate(Percentage = (Num_Students / total_students) * 100)

# Display the distribution in a formatted table with a colored header
knitr::kable(distribution, col.names = c("Number of Semesters", "Number of Students", "% of Total"), caption = "Distribution of Semesters to Graduation") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light gray header
```
As verified by this table, I see that a good chunk of my majority (87%) of all IS and Cybersecurity Management students graduate in 8 semesters. This remains consistent with my analysis of Business Analytics, and, barring any drastic discoveries in my credit hours columns, we should be good to proceed by classifying by the number of semesters.

### Count of Student Grade Classification by Credit Hours
Before we examine the possibility of classifying students as per the number of semesters they have completed at Miami, let's first take a look into our data to see what the distribution of the number of credit hours students complete when they graduate.


```{r, echo=FALSE}
# Step 1: Identify the maximum Term.Code for each student
IS <- IS |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(max_term_code = max(Term.Code)) |>
  dplyr::ungroup()

# Step 2: Identify graduated students by comparing Term.Code.Graduated to their max Term.Code
IS <- IS |>
  dplyr::mutate(graduated = ifelse(Term.Code == Term.Code.Graduated & Term.Code == max_term_code, TRUE, FALSE))

# Step 3: Filter for students who have graduated and capture their cumulative credit hours at graduation
graduated_students <- IS |>
  dplyr::filter(graduated == TRUE, Term.Code < 202510, Cum.Credit.Hours >= 120) |>
  dplyr::select(Student.ID, Cum.Credit.Hours)

# Step 4: Visualize the distribution of cumulative credit hours at graduation
if(require(ggplot2)==FALSE) install.packages("ggplot2")
ggplot2::ggplot(graduated_students, ggplot2::aes(x = Cum.Credit.Hours)) +
  ggplot2::geom_histogram(binwidth = 5, color = "black", fill = "#C8102E", alpha = 0.7) +
  ggplot2::labs(
    title = "Distribution of Cumulative Credit Hours at Graduation",
    x = "Cumulative Credit Hours",
    y = "Number of Students"
  ) +
  ggplot2::theme_minimal()

```
As shown by this graph, students will graduate from Miami University with a wide variety of cumulative credit hours completed. This data could somewhat be impacted by how many transfer credits that a student has from high school, their number of majors and minors, and potentially if they want to be CPA eligible. Below we will detail some further statistics regarding those in our data set who have graduated with an Information Systems Degree.

Below we will detail some further statistics regarding those in our data set who have graduated with an Information Systems Degree.

```{r, echo=FALSE}
# Step 1: Filter for graduated students and ensure non-missing credit hours
graduated_students <- IS %>% 
  filter(graduated == TRUE & !is.na(Cum.Credit.Hours), Term.Code.Graduated < 202510, Cum.Credit.Hours>=120)  # Only include graduated students with valid credit hours

# Step 2: Calculate the min, mean, and max number of Cum.Credit.Hrs for graduated students
graduation_stats <- graduated_students %>%
  summarise(
    min_credit_hours = min(Cum.Credit.Hours, na.rm = TRUE),
    mean_credit_hours = mean(Cum.Credit.Hours, na.rm = TRUE),
    max_credit_hours = max(Cum.Credit.Hours, na.rm = TRUE)
  )

# Rename the columns before using kable
colnames(graduation_stats) <- c("Minimum Credit Hours", "Mean Credit Hours", "Maximum Credit Hours")

# Create the table with customized headers and styling
knitr::kable(graduation_stats, caption = "Graduated Students' Cumulative Credit Hours Statistics") %>%
  # Apply bold styling to the header row and change background color
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "responsive"),
    full_width = F
  ) %>%
  kableExtra::column_spec(1:3, bold = TRUE) %>%  # Make header titles bold
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Change background color of the header row (light blue)
```

```{r, echo=FALSE}
# Assuming your data frame is named 'student_data'
result <- IS |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code)) |>
  dplyr::ungroup() |>
  dplyr::summarise(
    min_credit_hrs = min(Cum.Credit.Hours),
    median_credit_hrs = median(Cum.Credit.Hours),
    max_credit_hrs = max(Cum.Credit.Hours)
  )

# Create the table with customized headers and styling
knitr::kable(result, caption = "Cumulative Credit Hours Statistics for First Term") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "responsive"),
    full_width = FALSE
  ) |>
  kableExtra::column_spec(1:3, bold = TRUE) |>  # Make header titles bold
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Change background color of the header row (light blue)
```

```{r, echo=FALSE}
# Step 1: Filter for graduated students and ensure non-missing credit hours
graduated_students <- IS |>
  dplyr::filter(graduated == TRUE & !is.na(Cum.Credit.Hours))

# Step 2: Determine the number of majors for each student in their last term
graduated_students <- graduated_students |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::mutate(
    num_majors = dplyr::case_when(
      Major.1 != "None" & Major.2 == "None" & Major.3 == "None" ~ 1,
      Major.1 != "None" & Major.2 != "None" & Major.3 == "None" ~ 2,
      Major.1 != "None" & Major.2 != "None" & Major.3 != "None" ~ 3,
      TRUE ~ 0
    )
  ) |>
  dplyr::ungroup()

# Step 3: Calculate the mean number of Cum.Credit.Hrs for each group of majors
graduation_stats <- graduated_students |>
  dplyr::group_by(num_majors) |>
  dplyr::summarise(
    mean_credit_hours = mean(Cum.Credit.Hours, na.rm = TRUE)
  )

# Rename the columns before using kable
colnames(graduation_stats) <- c("Number of Majors", "Mean Credit Hours")

# Create the table with customized headers and styling
knitr::kable(graduation_stats, caption = "Mean Credit Hours by Number of Majors for Graduated Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "responsive"),
    full_width = FALSE
  ) |>
  kableExtra::column_spec(1:2, bold = TRUE) |>  # Make header titles bold
  kableExtra::row_spec(0, background = "#C8102E", color="white")
```
From these three tables I am able to obtain a few insights that I can bring into future analyses: 

1. Students graduate from Miami's Information Systems Majors with a wide variety of credit hours. 
2. Students often will tranfer credit to Miami University from high school or from another higher institution...in a later analysis, it would be worth looking into the particular student who transferred in 87 hours.
3. As students increase their amount of majors, they are also increasing the number of credits they graduate with. This may be an important factor to consider when classifying student grades.


To proceed, we will explore the possibility of classifying students by the number of credit hours they have completed.

In our previous analyses, we were exploring the potential of classifying students in our database based upon the number of semesters they have been enrolled at Miami University. However, another potential area we may explore to classify students is based on the number of cumulative credit hours they have completed, whether at Miami University or elsewhere. Many students may have transfer credits through AP coursework from high school or from another college if they transferred. We suspect that BannerWeb is currently classifying students based on the number of cumulative credit hours they have completed currently, but have no inclination if that is true.

```{r, echo=FALSE}
IS |> 
    dplyr::filter(
      (Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major")
  ) |> 
  dplyr::mutate(Classification = dplyr::case_when(
    Cum.Credit.Hours >= 0 & Cum.Credit.Hours < 30 ~ "Freshman",
    Cum.Credit.Hours >= 30 & Cum.Credit.Hours < 60 ~ "Sophomore",
    Cum.Credit.Hours >= 60 & Cum.Credit.Hours < 90 ~ "Junior",
    Cum.Credit.Hours >= 90 ~ "Senior"
  )) |> 
  dplyr::group_by(Term.Code, Classification) |> 
  dplyr::summarise(Num_Students = dplyr::n_distinct(Student.ID)) |> 
  print()
```
I operationally defined a student's credit hour intake as follows:

* If a student is in their first semester they are automatically classified as a freshman.
* If a student has between 0-30 credit hours, they are classified as a freshman.
* If a student has between 30-60 credit hours, they are classified as a sophomore.
* If a student has between 60-90 credit hours, they are classified as a junior.
* If a student has 90+ credit hours, they are classified as a senior.

When I classify a student's grade classification, assuming that on average each student completes 15 credit hours per semester, I start to notice a couple of problems. For starters, let's examine the incoming pipeline number for last fall:  

```{r,echo=FALSE}
# Step 1: Calculate cumulative credit hours before the term 202410
IS_prior <- IS |>
  dplyr::filter(Term.Code < 202410) |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarise(Cum.Credit.Hours.Before = max(Cum.Credit.Hours, na.rm = TRUE), .groups = 'drop')
# Step 2: Join with the original data to get the classification based on credit hours before 202410
result <- IS |>
  dplyr::filter(
    (Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major") & 
      Term.Code == 202410
  ) |>
  dplyr::left_join(IS_prior, by = "Student.ID") |>
  dplyr::mutate(Cum.Credit.Hours.Before = dplyr::if_else(is.na(Cum.Credit.Hours.Before), 0, Cum.Credit.Hours.Before)) |>
  dplyr::mutate(Classification = dplyr::case_when(
    Cum.Credit.Hours.Before >= 0 & Cum.Credit.Hours.Before < 30 ~ "Freshmen",
    Cum.Credit.Hours.Before >= 30 & Cum.Credit.Hours.Before < 60 ~ "Sophomore",
    Cum.Credit.Hours.Before >= 60 & Cum.Credit.Hours.Before < 90 ~ "Junior",
    Cum.Credit.Hours.Before >= 90 ~ "Senior"
  )) |>
  dplyr::mutate(Classification = factor(Classification, levels = c("Freshmen", "Sophomore", "Junior", "Senior"))) |>
  dplyr::group_by(Term.Code, Classification) |>
  dplyr::summarise(Num_Students = dplyr::n_distinct(Student.ID), .groups = 'drop') |>
  dplyr::arrange(Classification)
# Display the result in a formatted table
if(require(knitr)==FALSE) install.packages("knitr")
if(require(kableExtra)==FALSE) install.packages("kableExtra")
knitr::kable(result, col.names = c("Term Code", "Classification", "Number of Students"), caption = "Student Classification for Spring 2024") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light gray header
```
As I look at this data, I see that my incoming pipeline numbers for seniors do not come close to matching the number of seniors who graduated in the academic year 2023-2024. From this, we are able to make two key conclusions: 

1. The number of cumulative credit hours a student has completed does not reflect their status to graduate.
2. While coming in with transfer credits is certainly beneficial for students, it is not always beneficial in helping them fill requirements for their particular degree program, which ultimately dictates their timeline to graduate.

### Cases of Students Graduating Early

Let's start by looking at the overall breakdown of these students who have graduated early with an Information Systems major.

```{r, echo=FALSE}
# Identify students who have graduated and have "BA Major" in their graduation term
graduated_students <- IS |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == Term.Code.Graduated) |>
  dplyr::filter(Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major") |>
  dplyr::ungroup()

# Count the number of unique Term.Code entries for each Student.ID
semester_counts <- IS |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarize(Semester_Count = dplyr::n_distinct(Term.Code), .groups = 'drop')

# Join the semester counts with the graduated students
graduated_students <- graduated_students |>
  dplyr::inner_join(semester_counts, by = "Student.ID")

# Summarize the distribution of semester counts
distribution <- graduated_students |>
  dplyr::group_by(Semester_Count) |>
  dplyr::summarize(Num_Students = dplyr::n(), .groups = 'drop')

# Filter for students graduating in less than 8 semesters
distribution <- distribution |>
  dplyr::filter(Semester_Count < 8)

# Calculate the total number of students
total_students <- sum(distribution$Num_Students)

# Add a percentage column
distribution <- distribution |>
  dplyr::mutate(Percentage = (Num_Students / total_students) * 100)

# Display the distribution in a formatted table with a colored header
knitr::kable(distribution, col.names = c("Number of Semesters", "Number of Students", "% of Total"), caption = "Distribution of Semesters to Graduation for BA Majors") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header

```

Let's look at student's who graduated in 6 semesters:

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 6 semesters
students_6_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 6) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the IS dataframe for these students
students_6_semesters_data <- IS |>
  dplyr::filter(Student.ID %in% students_6_semesters$Student.ID)

# Step 3: Filter for students who have "IS Major" in their final term
students_with_is_major <- students_6_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_6_semesters <- students_6_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_is_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hours, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out students who graduated in term 202510
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::filter(Term.Code != 202510)

# Display the distribution in a formatted table with a colored header
knitr::kable(graduated_students_6_semesters, 
             col.names = c("Student ID", "Cohort Term", "Term Code", "Cumulative Credit Hours", "Cumulative GPA", "Major(s)"), 
             caption = "Distribution of Semesters to Graduation") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header

```

Above is the table showing the stats for students who graduated from Miami University in just 6 semesters with a degree in Information Systems. Let's summarize some of this detail at a high level:

```{r, echo=FALSE}
# Calculate the mean number of credit hours during the first semester
mean_first_semester_credits <- graduated_students_6_semesters |>
  dplyr::filter(Term.Code == Cohort.Term) |>
  dplyr::summarize(mean_credits = mean(`Cum.Credit.Hours`, na.rm = TRUE)) |>
  dplyr::pull(mean_credits)

# Calculate the mean GPA at graduation
mean_graduation_gpa <- graduated_students_6_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::summarize(mean_gpa = mean(`Cum.UG.Crs.GPA`, na.rm = TRUE)) |>
  dplyr::pull(mean_gpa) |> 
  mean(na.rm = TRUE)  # Get the overall mean across all students

# Calculate the percentage of students who graduated with more than one major
# We only want one result for the percentage, not grouped by Student.ID
percentage_more_than_one_major <- graduated_students_6_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::mutate(num_majors = stringr::str_count(All_Majors, ", ") + 1) |>
  dplyr::summarize(more_than_one_major = sum(num_majors > 1)) |>
  dplyr::ungroup() |>
  dplyr::summarize(percentage = (sum(more_than_one_major > 0) / n()) * 100) |>
  dplyr::pull(percentage)

# Create a summary table with a single row
summary_table <- tibble::tibble(
  `Mean First Semester Credits` = mean_first_semester_credits,
  `Mean Graduation GPA` = mean_graduation_gpa,
  `Percentage with More Than One Major` = percentage_more_than_one_major
)

# Display the summary table
knitr::kable(summary_table, 
             caption = "Summary of Student Graduation Data") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color = "white")  # Apply colored header

```

Another factor we want to examine is how many credit hours these students are taking per semester. Students who may be taking more credit hours may be on track to graduate earlier.

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 6 semesters
students_6_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 6) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the IS dataframe for these students
students_6_semesters_data <- IS |>
  dplyr::filter(Student.ID %in% students_6_semesters$Student.ID)

# Step 3: Filter for students who have "IS Major" in their final term
students_with_is_major <- students_6_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_6_semesters <- students_6_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_is_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hours, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out students who graduated in term 202510
graduated_students_6_semesters <- graduated_students_6_semesters |>
  dplyr::filter(Term.Code != 202510)

# Step 8: Calculate the credit hours per semester
credit_hours_per_semester <- students_6_semesters_data |>
  dplyr::filter(Student.ID %in% graduated_students_6_semesters$Student.ID) |>
  dplyr::arrange(Student.ID, Term.Code) |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(Credit_Hours_Semester = Cum.Credit.Hours - dplyr::lag(Cum.Credit.Hours, default = 0)) |>
  dplyr::ungroup()

# Step 9: Calculate the aggregated average credit hours per semester
total_credit_hours <- sum(credit_hours_per_semester$Credit_Hours_Semester, na.rm = TRUE)
total_semesters <- nrow(credit_hours_per_semester)
avg_credit_hours_per_semester_aggregated <- total_credit_hours / total_semesters

# Display the aggregated average credit hours per semester
knitr::kable(data.frame(Average_Credit_Hours_Per_Semester = avg_credit_hours_per_semester_aggregated), 
             col.names = c("Average Credit Hours per Semester"), 
             caption = "Aggregated Average Credit Hours per Semester for Graduated Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

The average credit hour intake for all students is shown below:

```{r, echo=FALSE}
# Calculate the credit hours per semester for all students
credit_hours_per_semester_all <- IS |>
  dplyr::arrange(Student.ID, Term.Code) |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(Credit_Hours_Semester = Cum.Credit.Hours - dplyr::lag(Cum.Credit.Hours, default = 0)) |>
  dplyr::ungroup()

# Calculate the aggregated average credit hours per semester for all students
total_credit_hours_all <- sum(credit_hours_per_semester_all$Credit_Hours_Semester, na.rm = TRUE)
total_semesters_all <- nrow(credit_hours_per_semester_all)
avg_credit_hours_per_semester_all <- total_credit_hours_all / total_semesters_all

# Display the aggregated average credit hours per semester for all students
knitr::kable(data.frame(Average_Credit_Hours_Per_Semester = avg_credit_hours_per_semester_all), 
             col.names = c("Average Credit Hours per Semester"), 
             caption = "Aggregated Average Credit Hours per Semester for All Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```
As we can see, the average number of credit hours the IS students who are graduating early are taking is significantly greater than the average amount of credit hours for that major, which is a big explanation why they are on the fast-track for graduation. However, it is important to note that we have few observations for these IS students in our database, leaving them more susceptible to outliers.

Similarly to what we noticed with the BA data, these students have a high number of credit hours after their first semester, which is a potential signal that they had a substantial amount of transfer credit from their high school career. In addition, none of these students have another major, meaning that all of their focus is on the IS department.

### Cases of Students Graduating Late

Let's show the distribution of students who have taken longer than 8 semesters to graduate:

```{r, echo=FALSE}
# Identify students who have graduated and have "IS Major" in their graduation term
graduated_students <- IS |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == Term.Code.Graduated) |>
  dplyr::filter(Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major")  |>
  dplyr::ungroup()

# Count the number of unique Term.Code entries for each Student.ID
semester_counts <- IS |>
  dplyr::group_by(Student.ID) |>
  dplyr::summarize(Semester_Count = dplyr::n_distinct(Term.Code), .groups = 'drop')

# Join the semester counts with the graduated students
graduated_students <- graduated_students |>
  dplyr::inner_join(semester_counts, by = "Student.ID")

# Summarize the distribution of semester counts
distribution <- graduated_students |>
  dplyr::group_by(Semester_Count) |>
  dplyr::summarize(Num_Students = dplyr::n(), .groups = 'drop')

# Filter for students graduating in less than 8 semesters
distribution <- distribution |>
  dplyr::filter(Semester_Count > 8)

# Calculate the total number of students
total_students <- sum(distribution$Num_Students)

# Add a percentage column
distribution <- distribution |>
  dplyr::mutate(Percentage = (Num_Students / total_students) * 100)

# Display the distribution in a formatted table with a colored header
knitr::kable(distribution, col.names = c("Number of Semesters", "Number of Students", "% of Total"), caption = "Distribution of Semesters to Graduation for BA Majors") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```
 
Let's start by drilling into the student who took 9 semesters to obtain a degree in Information Systems.

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 9 semesters
students_9_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 9) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the IS dataframe for these students
students_9_semesters_data <- IS |>
  dplyr::filter(Student.ID %in% students_9_semesters$Student.ID)

# Step 3: Filter for students who have "IS Major" in their final term
students_with_is_major <- students_9_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major")  |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_9_semesters <- students_9_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_is_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hours, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out student ID 8226483
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::filter(Student.ID != 8226483)

# Display the distribution in a formatted table with a colored header
knitr::kable(graduated_students_9_semesters, 
             col.names = c("Student ID", "Cohort Term", "Term Code", "Cumulative Credit Hours", "Cumulative GPA", "Major(s)"), 
             caption = "Distribution of Semesters to Graduation") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

This table shows the details for both the student's first and last semester assuming they graduated in 9 semesters. Here are some of the high level statistics:

```{r, echo=FALSE}
# Calculate the mean number of credit hours during the first semester
mean_first_semester_credits <- graduated_students_9_semesters |>
  dplyr::filter(Term.Code == Cohort.Term) |>
  dplyr::summarize(mean_credits = mean(`Cum.Credit.Hours`, na.rm = TRUE)) |>
  dplyr::pull(mean_credits)

# Calculate the mean GPA at graduation
mean_graduation_gpa <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::summarize(mean_gpa = mean(`Cum.UG.Crs.GPA`, na.rm = TRUE)) |>
  dplyr::pull(mean_gpa) |> 
  mean(na.rm = TRUE)  # Get the overall mean across all students

# Calculate the percentage of students who graduated with more than one major
# We only want one result for the percentage, not grouped by Student.ID
percentage_more_than_one_major <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::mutate(num_majors = stringr::str_count(All_Majors, ", ") + 1) |>
  dplyr::summarize(more_than_one_major = sum(num_majors > 1)) |>
  dplyr::ungroup() |>
  dplyr::summarize(percentage = (sum(more_than_one_major > 0) / n()) * 100) |>
  dplyr::pull(percentage)

# Create a summary table with a single row
summary_table <- tibble::tibble(
  `Mean First Semester Credits` = mean_first_semester_credits,
  `Mean Graduation GPA` = mean_graduation_gpa,
  `Percentage with More Than One Major` = percentage_more_than_one_major
)

# Display the summary table
knitr::kable(summary_table, 
             caption = "Summary of Student Graduation Data") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color = "white")  # Apply colored header
```

While this student has a higher number of first semester credits, this student had an undeclared business major. In addition we see that this student has a much lower GPA than students who graduate early. Let's check the average graduation GPA to see if this differs significantly.

```{r, echo=FALSE}
# Step 1: Identify students who graduated with a "IS Major"
students_with_is_major <- IS |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major")|>
  dplyr::ungroup()

# Step 2: Calculate the average GPA for these students
average_gpa_is_major <- students_with_is_major |>
  dplyr::summarize(Average_GPA = mean(Cum.UG.Crs.GPA, na.rm = TRUE))

# Display the average GPA
knitr::kable(average_gpa_is_major, 
             col.names = c("Average GPA"), 
             caption = "Average GPA for Students Graduated with IS Major") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 6 semesters
students_9_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 9) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the IS dataframe for these students
students_9_semesters_data <- IS |>
  dplyr::filter(Student.ID %in% students_9_semesters$Student.ID)

# Step 3: Filter for students who have "IS Major" in their final term
students_with_is_major <- students_9_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_9_semesters <- students_9_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_is_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hours, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out students who graduated in term 202510
graduated_students_9_semesters <- graduated_students_9_semesters |>
  dplyr::filter(Term.Code != 202510)

# Step 8: Calculate the credit hours per semester
credit_hours_per_semester <- students_9_semesters_data |>
  dplyr::filter(Student.ID %in% graduated_students_9_semesters$Student.ID) |>
  dplyr::arrange(Student.ID, Term.Code) |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(Credit_Hours_Semester = Cum.Credit.Hours - dplyr::lag(Cum.Credit.Hours, default = 0)) |>
  dplyr::ungroup()

# Step 9: Calculate the aggregated average credit hours per semester
total_credit_hours <- sum(credit_hours_per_semester$Credit_Hours_Semester, na.rm = TRUE)
total_semesters <- nrow(credit_hours_per_semester)
avg_credit_hours_per_semester_aggregated <- total_credit_hours / total_semesters

# Display the aggregated average credit hours per semester
knitr::kable(data.frame(Average_Credit_Hours_Per_Semester = avg_credit_hours_per_semester_aggregated), 
             col.names = c("Average Credit Hours per Semester"), 
             caption = "Aggregated Average Credit Hours per Semester for Graduated Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

This data confirms our assumption that students who have graduated in 9 semesters have taken less of a credit hour load than the normal student body. The average amount of credit hours that students are completing on a semesterly basis may be something for the ISA department to consider as they track student progress, and potentially try and flag students who are falling behind.

Now that we have closely examined student who  graduated in 9 semesters, let's see if this pattern is still true for the students who graduated in 10 semesters.

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 10 semesters
students_10_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 10) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the IS dataframe for these students
students_10_semesters_data <- IS |>
  dplyr::filter(Student.ID %in% students_10_semesters$Student.ID)

# Step 3: Filter for students who have "IS Major" in their final term
students_with_is_major <- students_10_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "IS Major" | 
     Major.2 == "IS Major" | 
     Major.3 == "IS Major" |
     Major.1 == "Cybersecurity Mgt Major" | 
     Major.2 == "Cybersecurity Mgt Major" | 
     Major.3 == "Cybersecurity Mgt Major")|>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_10_semesters <- students_10_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_is_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hours, Cum.UG.Crs.GPA, All_Majors)

# Display the distribution in a formatted table with a colored header
knitr::kable(graduated_students_10_semesters, 
             col.names = c("Student ID", "Cohort Term", "Term Code", "Cumulative Credit Hours", "Cumulative GPA", "Major(s)"), 
             caption = "Distribution of Semesters to Graduation") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::column_spec(2) |>
  kableExtra::column_spec(3) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

Let's look at some of these factors on a higher level: 

```{r, echo=FALSE}
# Calculate the mean number of credit hours during the first semester
mean_first_semester_credits <- graduated_students_10_semesters |>
  dplyr::filter(Term.Code == Cohort.Term) |>
  dplyr::summarize(mean_credits = mean(`Cum.Credit.Hours`, na.rm = TRUE)) |>
  dplyr::pull(mean_credits)

# Calculate the mean GPA at graduation
mean_graduation_gpa <- graduated_students_10_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::summarize(mean_gpa = mean(`Cum.UG.Crs.GPA`, na.rm = TRUE)) |>
  dplyr::pull(mean_gpa) |> 
  mean(na.rm = TRUE)  # Get the overall mean across all students

# Calculate the percentage of students who graduated with more than one major
# We only want one result for the percentage, not grouped by Student.ID
percentage_more_than_one_major <- graduated_students_9_semesters |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::mutate(num_majors = stringr::str_count(All_Majors, ", ") + 1) |>
  dplyr::summarize(more_than_one_major = sum(num_majors > 1)) |>
  dplyr::ungroup() |>
  dplyr::summarize(percentage = (sum(more_than_one_major > 0) / n()) * 100) |>
  dplyr::pull(percentage)

# Create a summary table with a single row
summary_table <- tibble::tibble(
  `Mean First Semester Credits` = mean_first_semester_credits,
  `Mean Graduation GPA` = mean_graduation_gpa,
  `Percentage with More Than One Major` = percentage_more_than_one_major
)

# Display the summary table
knitr::kable(summary_table, 
             caption = "Summary of Student Graduation Data") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::row_spec(0, background = "#C8102E", color = "white")  # Apply colored header
```

Similarly to the students who graduated with an Information Systems major in 9 semesters, those who graduated in 10 semesters have switched their majors since their first semester.

Let's see if the number of credit hours they are taking per semester has an impact on their graduation.

```{r, echo=FALSE}
# Step 1: Identify students who graduated in 10 semesters
students_10_semesters <- semester_counts |>
  dplyr::filter(Semester_Count == 10) |>
  dplyr::select(Student.ID)

# Step 2: Get the rows from the IS dataframe for these students
students_10_semesters_data <- IS |>
  dplyr::filter(Student.ID %in% students_10_semesters$Student.ID)

# Step 3: Filter for students who have "IS Major" in their final term
students_with_is_major <- students_10_semesters_data |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == max(Term.Code)) |>
  dplyr::filter(Major.1 == "IS Major" | Major.2 == "IS Major" | Major.3 == "IS Major") |>
  dplyr::ungroup()

# Step 4: Select only the first and last row for each Student.ID (first and last semester)
graduated_students_10_semesters <- students_10_semesters_data |>
  dplyr::filter(Student.ID %in% students_with_is_major$Student.ID) |>
  dplyr::group_by(Student.ID) |>
  dplyr::filter(Term.Code == min(Term.Code) | Term.Code == max(Term.Code)) |>
  dplyr::ungroup()

# Step 5: For the first and last semester, collapse majors into a single column (one for each row)
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::group_by(Student.ID, Term.Code) |>
  dplyr::mutate(All_Majors = paste(unique(na.omit(c(Major.1, Major.2, Major.3)[c(Major.1, Major.2, Major.3) != "None"])), collapse = ", ")) |>
  dplyr::ungroup()

# Step 6: Remove duplicate rows by Student.ID and Term.Code (to avoid repeated majors for students with multiple majors)
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE) |>
  dplyr::select(Student.ID, Cohort.Term, Term.Code, Cum.Credit.Hours, Cum.UG.Crs.GPA, All_Majors)

# Step 7: Filter out students who graduated in term 202510
graduated_students_10_semesters <- graduated_students_10_semesters |>
  dplyr::filter(Term.Code != 202510)

# Step 8: Calculate the credit hours per semester
credit_hours_per_semester <- students_10_semesters_data |>
  dplyr::filter(Student.ID %in% graduated_students_10_semesters$Student.ID) |>
  dplyr::arrange(Student.ID, Term.Code) |>
  dplyr::group_by(Student.ID) |>
  dplyr::mutate(Credit_Hours_Semester = Cum.Credit.Hours - dplyr::lag(Cum.Credit.Hours, default = 0)) |>
  dplyr::ungroup()

# Step 9: Calculate the aggregated average credit hours per semester
total_credit_hours <- sum(credit_hours_per_semester$Credit_Hours_Semester, na.rm = TRUE)
total_semesters <- nrow(credit_hours_per_semester)
avg_credit_hours_per_semester_aggregated <- total_credit_hours / total_semesters

# Display the aggregated average credit hours per semester
knitr::kable(data.frame(Average_Credit_Hours_Per_Semester = avg_credit_hours_per_semester_aggregated), 
             col.names = c("Average Credit Hours per Semester"), 
             caption = "Aggregated Average Credit Hours per Semester for Graduated Students") |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    position = "center"
  ) |>
  kableExtra::column_spec(1) |>
  kableExtra::row_spec(0, background = "#C8102E", color="white")  # Light blue header
```

Conversely to students who graduated in 9 semesters, students who took 10 semesters to graduate have more average credit hours per semester than the average Information Systems graduate. This is most likely due to these students switching their major later into their academic year.

For the most part, the same trends existed across both BA and IS graduates for both early and late graduates. However, it is important to note that the IS data has a much smaller sample size, and thus we were only looking at information for only 2-3 students, which may not tell the whole story.

### IS Conclusion
Similarly to our Business Analytics majors, we will classify the students in our IS dataset by the number of semesters they have completed. This change will be reflected in our new table by making the following changes:
```{r, echo=FALSE}
# Step 1: Ensure unique term codes for each student
IS_unique_terms <- IS |>
  dplyr::distinct(Student.ID, Term.Code, .keep_all = TRUE)
# Step 2: Calculate the number of semesters completed for each student up to each term
IS_with_semesters <- IS_unique_terms |>
  dplyr::group_by(Student.ID) |>
  dplyr::arrange(Term.Code) |>
  dplyr::mutate(Semesters_Completed = dplyr::row_number() - 1) |>
  dplyr::ungroup()
# Step 3: Add classification based on the number of semesters completed
IS_with_classification <- IS_with_semesters |>
  dplyr::mutate(Classification = dplyr::case_when(
    Semesters_Completed < 2 ~ "Freshman",
    Semesters_Completed == 2 | Semesters_Completed == 3 ~ "Sophomore",
    Semesters_Completed == 4 | Semesters_Completed == 5 ~ "Junior",
    Semesters_Completed == 6 | Semesters_Completed == 7 ~ "Senior",
    Semesters_Completed >= 8 ~ "Super Senior"
  )) |>
  dplyr::mutate(Classification = factor(Classification, levels = c("Freshman", "Sophomore", "Junior", "Senior", "Super Senior"))) |>
  dplyr::arrange(Student.ID, Term.Code)  # Sort by Student.ID and Term.Code
# Display a sample of the updated dataset
head(IS_with_classification)
```

# **Conclusion**
To wrap up our project, we will proceed for now by classifying students using the number of semesters they have completed as it is the most reliable method with our current data. However, here are a few recommendations our team has for the future.

1. Obtain additional information, such a student's minor, that may lead to a more precise classification.
2. Create a check in R to flag students who may potentially be on track to graduate early or late based on their credit hours completion rates, transfer hours, or major changes.


